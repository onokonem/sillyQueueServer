// Code generated by protoc-gen-go. DO NOT EDIT.
// source: queueproto.proto

/*
Package queueproto is a generated protocol buffer package.

It is generated from these files:
	queueproto.proto

It has these top-level messages:
	AckToHub
	AckFromHub
	QueueTask
	Queued
	Rejected
	Attached
	Subscribed
	Accept
	Attach
	Subscribe
	Ping
	Pong
	Accepted
	Done
	Timeouted
	Aborted
	Dismissed
	InProgress
*/
package queueproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type QueueTask_Persistence int32

const (
	QueueTask_Writetrough QueueTask_Persistence = 0
	QueueTask_Writeback   QueueTask_Persistence = 1
	QueueTask_None        QueueTask_Persistence = 2
)

var QueueTask_Persistence_name = map[int32]string{
	0: "Writetrough",
	1: "Writeback",
	2: "None",
}
var QueueTask_Persistence_value = map[string]int32{
	"Writetrough": 0,
	"Writeback":   1,
	"None":        2,
}

func (x QueueTask_Persistence) String() string {
	return proto.EnumName(QueueTask_Persistence_name, int32(x))
}
func (QueueTask_Persistence) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type QueueTask_Delivery int32

const (
	QueueTask_Anyone               QueueTask_Delivery = 0
	QueueTask_Everyone             QueueTask_Delivery = 1
	QueueTask_EveryoneNowAndFuture QueueTask_Delivery = 2
)

var QueueTask_Delivery_name = map[int32]string{
	0: "Anyone",
	1: "Everyone",
	2: "EveryoneNowAndFuture",
}
var QueueTask_Delivery_value = map[string]int32{
	"Anyone":               0,
	"Everyone":             1,
	"EveryoneNowAndFuture": 2,
}

func (x QueueTask_Delivery) String() string {
	return proto.EnumName(QueueTask_Delivery_name, int32(x))
}
func (QueueTask_Delivery) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 1} }

type AckToHub struct {
	// Types that are valid to be assigned to Msg:
	//	*AckToHub_Attach
	//	*AckToHub_Subscribe
	//	*AckToHub_Queue
	//	*AckToHub_Ping
	//	*AckToHub_Accepted
	//	*AckToHub_Done
	//	*AckToHub_InProgress
	//	*AckToHub_Dismissed
	Msg isAckToHub_Msg `protobuf_oneof:"msg"`
}

func (m *AckToHub) Reset()                    { *m = AckToHub{} }
func (m *AckToHub) String() string            { return proto.CompactTextString(m) }
func (*AckToHub) ProtoMessage()               {}
func (*AckToHub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isAckToHub_Msg interface {
	isAckToHub_Msg()
}

type AckToHub_Attach struct {
	Attach *Attach `protobuf:"bytes,1,opt,name=attach,oneof"`
}
type AckToHub_Subscribe struct {
	Subscribe *Subscribe `protobuf:"bytes,2,opt,name=subscribe,oneof"`
}
type AckToHub_Queue struct {
	Queue *QueueTask `protobuf:"bytes,3,opt,name=queue,oneof"`
}
type AckToHub_Ping struct {
	Ping *Ping `protobuf:"bytes,5,opt,name=ping,oneof"`
}
type AckToHub_Accepted struct {
	Accepted *Accepted `protobuf:"bytes,10,opt,name=accepted,oneof"`
}
type AckToHub_Done struct {
	Done *Done `protobuf:"bytes,11,opt,name=done,oneof"`
}
type AckToHub_InProgress struct {
	InProgress *InProgress `protobuf:"bytes,12,opt,name=inProgress,oneof"`
}
type AckToHub_Dismissed struct {
	Dismissed *Dismissed `protobuf:"bytes,13,opt,name=dismissed,oneof"`
}

func (*AckToHub_Attach) isAckToHub_Msg()     {}
func (*AckToHub_Subscribe) isAckToHub_Msg()  {}
func (*AckToHub_Queue) isAckToHub_Msg()      {}
func (*AckToHub_Ping) isAckToHub_Msg()       {}
func (*AckToHub_Accepted) isAckToHub_Msg()   {}
func (*AckToHub_Done) isAckToHub_Msg()       {}
func (*AckToHub_InProgress) isAckToHub_Msg() {}
func (*AckToHub_Dismissed) isAckToHub_Msg()  {}

func (m *AckToHub) GetMsg() isAckToHub_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *AckToHub) GetAttach() *Attach {
	if x, ok := m.GetMsg().(*AckToHub_Attach); ok {
		return x.Attach
	}
	return nil
}

func (m *AckToHub) GetSubscribe() *Subscribe {
	if x, ok := m.GetMsg().(*AckToHub_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *AckToHub) GetQueue() *QueueTask {
	if x, ok := m.GetMsg().(*AckToHub_Queue); ok {
		return x.Queue
	}
	return nil
}

func (m *AckToHub) GetPing() *Ping {
	if x, ok := m.GetMsg().(*AckToHub_Ping); ok {
		return x.Ping
	}
	return nil
}

func (m *AckToHub) GetAccepted() *Accepted {
	if x, ok := m.GetMsg().(*AckToHub_Accepted); ok {
		return x.Accepted
	}
	return nil
}

func (m *AckToHub) GetDone() *Done {
	if x, ok := m.GetMsg().(*AckToHub_Done); ok {
		return x.Done
	}
	return nil
}

func (m *AckToHub) GetInProgress() *InProgress {
	if x, ok := m.GetMsg().(*AckToHub_InProgress); ok {
		return x.InProgress
	}
	return nil
}

func (m *AckToHub) GetDismissed() *Dismissed {
	if x, ok := m.GetMsg().(*AckToHub_Dismissed); ok {
		return x.Dismissed
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AckToHub) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AckToHub_OneofMarshaler, _AckToHub_OneofUnmarshaler, _AckToHub_OneofSizer, []interface{}{
		(*AckToHub_Attach)(nil),
		(*AckToHub_Subscribe)(nil),
		(*AckToHub_Queue)(nil),
		(*AckToHub_Ping)(nil),
		(*AckToHub_Accepted)(nil),
		(*AckToHub_Done)(nil),
		(*AckToHub_InProgress)(nil),
		(*AckToHub_Dismissed)(nil),
	}
}

func _AckToHub_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AckToHub)
	// msg
	switch x := m.Msg.(type) {
	case *AckToHub_Attach:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Attach); err != nil {
			return err
		}
	case *AckToHub_Subscribe:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribe); err != nil {
			return err
		}
	case *AckToHub_Queue:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Queue); err != nil {
			return err
		}
	case *AckToHub_Ping:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ping); err != nil {
			return err
		}
	case *AckToHub_Accepted:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Accepted); err != nil {
			return err
		}
	case *AckToHub_Done:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Done); err != nil {
			return err
		}
	case *AckToHub_InProgress:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InProgress); err != nil {
			return err
		}
	case *AckToHub_Dismissed:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dismissed); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AckToHub.Msg has unexpected type %T", x)
	}
	return nil
}

func _AckToHub_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AckToHub)
	switch tag {
	case 1: // msg.attach
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attach)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Attach{msg}
		return true, err
	case 2: // msg.subscribe
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Subscribe)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Subscribe{msg}
		return true, err
	case 3: // msg.queue
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QueueTask)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Queue{msg}
		return true, err
	case 5: // msg.ping
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Ping)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Ping{msg}
		return true, err
	case 10: // msg.accepted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Accepted)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Accepted{msg}
		return true, err
	case 11: // msg.done
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Done)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Done{msg}
		return true, err
	case 12: // msg.inProgress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InProgress)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_InProgress{msg}
		return true, err
	case 13: // msg.dismissed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Dismissed)
		err := b.DecodeMessage(msg)
		m.Msg = &AckToHub_Dismissed{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AckToHub_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AckToHub)
	// msg
	switch x := m.Msg.(type) {
	case *AckToHub_Attach:
		s := proto.Size(x.Attach)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_Subscribe:
		s := proto.Size(x.Subscribe)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_Queue:
		s := proto.Size(x.Queue)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_Ping:
		s := proto.Size(x.Ping)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_Accepted:
		s := proto.Size(x.Accepted)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_Done:
		s := proto.Size(x.Done)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_InProgress:
		s := proto.Size(x.InProgress)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckToHub_Dismissed:
		s := proto.Size(x.Dismissed)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AckFromHub struct {
	// Types that are valid to be assigned to Msg:
	//	*AckFromHub_Attached
	//	*AckFromHub_Subscribed
	//	*AckFromHub_Queued
	//	*AckFromHub_Rejected
	//	*AckFromHub_Pong
	//	*AckFromHub_Accept
	//	*AckFromHub_Accepted
	//	*AckFromHub_Done
	//	*AckFromHub_InProgress
	//	*AckFromHub_Dismissed
	//	*AckFromHub_Timeouted
	//	*AckFromHub_Aborted
	Msg isAckFromHub_Msg `protobuf_oneof:"msg"`
}

func (m *AckFromHub) Reset()                    { *m = AckFromHub{} }
func (m *AckFromHub) String() string            { return proto.CompactTextString(m) }
func (*AckFromHub) ProtoMessage()               {}
func (*AckFromHub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isAckFromHub_Msg interface {
	isAckFromHub_Msg()
}

type AckFromHub_Attached struct {
	Attached *Attached `protobuf:"bytes,1,opt,name=attached,oneof"`
}
type AckFromHub_Subscribed struct {
	Subscribed *Subscribed `protobuf:"bytes,2,opt,name=subscribed,oneof"`
}
type AckFromHub_Queued struct {
	Queued *Queued `protobuf:"bytes,3,opt,name=queued,oneof"`
}
type AckFromHub_Rejected struct {
	Rejected *Rejected `protobuf:"bytes,4,opt,name=rejected,oneof"`
}
type AckFromHub_Pong struct {
	Pong *Pong `protobuf:"bytes,5,opt,name=pong,oneof"`
}
type AckFromHub_Accept struct {
	Accept *Accept `protobuf:"bytes,9,opt,name=accept,oneof"`
}
type AckFromHub_Accepted struct {
	Accepted *Accepted `protobuf:"bytes,10,opt,name=accepted,oneof"`
}
type AckFromHub_Done struct {
	Done *Done `protobuf:"bytes,11,opt,name=done,oneof"`
}
type AckFromHub_InProgress struct {
	InProgress *InProgress `protobuf:"bytes,12,opt,name=inProgress,oneof"`
}
type AckFromHub_Dismissed struct {
	Dismissed *Dismissed `protobuf:"bytes,13,opt,name=dismissed,oneof"`
}
type AckFromHub_Timeouted struct {
	Timeouted *Timeouted `protobuf:"bytes,14,opt,name=timeouted,oneof"`
}
type AckFromHub_Aborted struct {
	Aborted *Aborted `protobuf:"bytes,15,opt,name=aborted,oneof"`
}

func (*AckFromHub_Attached) isAckFromHub_Msg()   {}
func (*AckFromHub_Subscribed) isAckFromHub_Msg() {}
func (*AckFromHub_Queued) isAckFromHub_Msg()     {}
func (*AckFromHub_Rejected) isAckFromHub_Msg()   {}
func (*AckFromHub_Pong) isAckFromHub_Msg()       {}
func (*AckFromHub_Accept) isAckFromHub_Msg()     {}
func (*AckFromHub_Accepted) isAckFromHub_Msg()   {}
func (*AckFromHub_Done) isAckFromHub_Msg()       {}
func (*AckFromHub_InProgress) isAckFromHub_Msg() {}
func (*AckFromHub_Dismissed) isAckFromHub_Msg()  {}
func (*AckFromHub_Timeouted) isAckFromHub_Msg()  {}
func (*AckFromHub_Aborted) isAckFromHub_Msg()    {}

func (m *AckFromHub) GetMsg() isAckFromHub_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *AckFromHub) GetAttached() *Attached {
	if x, ok := m.GetMsg().(*AckFromHub_Attached); ok {
		return x.Attached
	}
	return nil
}

func (m *AckFromHub) GetSubscribed() *Subscribed {
	if x, ok := m.GetMsg().(*AckFromHub_Subscribed); ok {
		return x.Subscribed
	}
	return nil
}

func (m *AckFromHub) GetQueued() *Queued {
	if x, ok := m.GetMsg().(*AckFromHub_Queued); ok {
		return x.Queued
	}
	return nil
}

func (m *AckFromHub) GetRejected() *Rejected {
	if x, ok := m.GetMsg().(*AckFromHub_Rejected); ok {
		return x.Rejected
	}
	return nil
}

func (m *AckFromHub) GetPong() *Pong {
	if x, ok := m.GetMsg().(*AckFromHub_Pong); ok {
		return x.Pong
	}
	return nil
}

func (m *AckFromHub) GetAccept() *Accept {
	if x, ok := m.GetMsg().(*AckFromHub_Accept); ok {
		return x.Accept
	}
	return nil
}

func (m *AckFromHub) GetAccepted() *Accepted {
	if x, ok := m.GetMsg().(*AckFromHub_Accepted); ok {
		return x.Accepted
	}
	return nil
}

func (m *AckFromHub) GetDone() *Done {
	if x, ok := m.GetMsg().(*AckFromHub_Done); ok {
		return x.Done
	}
	return nil
}

func (m *AckFromHub) GetInProgress() *InProgress {
	if x, ok := m.GetMsg().(*AckFromHub_InProgress); ok {
		return x.InProgress
	}
	return nil
}

func (m *AckFromHub) GetDismissed() *Dismissed {
	if x, ok := m.GetMsg().(*AckFromHub_Dismissed); ok {
		return x.Dismissed
	}
	return nil
}

func (m *AckFromHub) GetTimeouted() *Timeouted {
	if x, ok := m.GetMsg().(*AckFromHub_Timeouted); ok {
		return x.Timeouted
	}
	return nil
}

func (m *AckFromHub) GetAborted() *Aborted {
	if x, ok := m.GetMsg().(*AckFromHub_Aborted); ok {
		return x.Aborted
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AckFromHub) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AckFromHub_OneofMarshaler, _AckFromHub_OneofUnmarshaler, _AckFromHub_OneofSizer, []interface{}{
		(*AckFromHub_Attached)(nil),
		(*AckFromHub_Subscribed)(nil),
		(*AckFromHub_Queued)(nil),
		(*AckFromHub_Rejected)(nil),
		(*AckFromHub_Pong)(nil),
		(*AckFromHub_Accept)(nil),
		(*AckFromHub_Accepted)(nil),
		(*AckFromHub_Done)(nil),
		(*AckFromHub_InProgress)(nil),
		(*AckFromHub_Dismissed)(nil),
		(*AckFromHub_Timeouted)(nil),
		(*AckFromHub_Aborted)(nil),
	}
}

func _AckFromHub_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AckFromHub)
	// msg
	switch x := m.Msg.(type) {
	case *AckFromHub_Attached:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Attached); err != nil {
			return err
		}
	case *AckFromHub_Subscribed:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribed); err != nil {
			return err
		}
	case *AckFromHub_Queued:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Queued); err != nil {
			return err
		}
	case *AckFromHub_Rejected:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rejected); err != nil {
			return err
		}
	case *AckFromHub_Pong:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pong); err != nil {
			return err
		}
	case *AckFromHub_Accept:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Accept); err != nil {
			return err
		}
	case *AckFromHub_Accepted:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Accepted); err != nil {
			return err
		}
	case *AckFromHub_Done:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Done); err != nil {
			return err
		}
	case *AckFromHub_InProgress:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InProgress); err != nil {
			return err
		}
	case *AckFromHub_Dismissed:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dismissed); err != nil {
			return err
		}
	case *AckFromHub_Timeouted:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Timeouted); err != nil {
			return err
		}
	case *AckFromHub_Aborted:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aborted); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AckFromHub.Msg has unexpected type %T", x)
	}
	return nil
}

func _AckFromHub_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AckFromHub)
	switch tag {
	case 1: // msg.attached
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attached)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Attached{msg}
		return true, err
	case 2: // msg.subscribed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Subscribed)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Subscribed{msg}
		return true, err
	case 3: // msg.queued
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Queued)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Queued{msg}
		return true, err
	case 4: // msg.rejected
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rejected)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Rejected{msg}
		return true, err
	case 5: // msg.pong
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Pong)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Pong{msg}
		return true, err
	case 9: // msg.accept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Accept)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Accept{msg}
		return true, err
	case 10: // msg.accepted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Accepted)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Accepted{msg}
		return true, err
	case 11: // msg.done
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Done)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Done{msg}
		return true, err
	case 12: // msg.inProgress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InProgress)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_InProgress{msg}
		return true, err
	case 13: // msg.dismissed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Dismissed)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Dismissed{msg}
		return true, err
	case 14: // msg.timeouted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Timeouted)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Timeouted{msg}
		return true, err
	case 15: // msg.aborted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aborted)
		err := b.DecodeMessage(msg)
		m.Msg = &AckFromHub_Aborted{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AckFromHub_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AckFromHub)
	// msg
	switch x := m.Msg.(type) {
	case *AckFromHub_Attached:
		s := proto.Size(x.Attached)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Subscribed:
		s := proto.Size(x.Subscribed)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Queued:
		s := proto.Size(x.Queued)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Rejected:
		s := proto.Size(x.Rejected)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Pong:
		s := proto.Size(x.Pong)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Accept:
		s := proto.Size(x.Accept)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Accepted:
		s := proto.Size(x.Accepted)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Done:
		s := proto.Size(x.Done)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_InProgress:
		s := proto.Size(x.InProgress)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Dismissed:
		s := proto.Size(x.Dismissed)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Timeouted:
		s := proto.Size(x.Timeouted)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AckFromHub_Aborted:
		s := proto.Size(x.Aborted)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type QueueTask struct {
	Queue       string                     `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	Id          string                     `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Subject     string                     `protobuf:"bytes,3,opt,name=subject" json:"subject,omitempty"`
	Originator  string                     `protobuf:"bytes,4,opt,name=originator" json:"originator,omitempty"`
	Timeout     uint64                     `protobuf:"varint,5,opt,name=timeout" json:"timeout,omitempty"`
	Persistence QueueTask_Persistence      `protobuf:"varint,6,opt,name=persistence,enum=QueueTask_Persistence" json:"persistence,omitempty"`
	Delivery    QueueTask_Delivery         `protobuf:"varint,7,opt,name=delivery,enum=QueueTask_Delivery" json:"delivery,omitempty"`
	Ack         *QueueTask_Acknowledgement `protobuf:"bytes,8,opt,name=ack" json:"ack,omitempty"`
	Payload     []byte                     `protobuf:"bytes,9,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *QueueTask) Reset()                    { *m = QueueTask{} }
func (m *QueueTask) String() string            { return proto.CompactTextString(m) }
func (*QueueTask) ProtoMessage()               {}
func (*QueueTask) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *QueueTask) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *QueueTask) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *QueueTask) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *QueueTask) GetOriginator() string {
	if m != nil {
		return m.Originator
	}
	return ""
}

func (m *QueueTask) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *QueueTask) GetPersistence() QueueTask_Persistence {
	if m != nil {
		return m.Persistence
	}
	return QueueTask_Writetrough
}

func (m *QueueTask) GetDelivery() QueueTask_Delivery {
	if m != nil {
		return m.Delivery
	}
	return QueueTask_Anyone
}

func (m *QueueTask) GetAck() *QueueTask_Acknowledgement {
	if m != nil {
		return m.Ack
	}
	return nil
}

func (m *QueueTask) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type QueueTask_Acknowledgement struct {
	Accepted  bool `protobuf:"varint,2,opt,name=accepted" json:"accepted,omitempty"`
	Done      bool `protobuf:"varint,3,opt,name=done" json:"done,omitempty"`
	Timeout   bool `protobuf:"varint,4,opt,name=timeout" json:"timeout,omitempty"`
	Aborted   bool `protobuf:"varint,5,opt,name=aborted" json:"aborted,omitempty"`
	Dismissed bool `protobuf:"varint,6,opt,name=dismissed" json:"dismissed,omitempty"`
}

func (m *QueueTask_Acknowledgement) Reset()                    { *m = QueueTask_Acknowledgement{} }
func (m *QueueTask_Acknowledgement) String() string            { return proto.CompactTextString(m) }
func (*QueueTask_Acknowledgement) ProtoMessage()               {}
func (*QueueTask_Acknowledgement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *QueueTask_Acknowledgement) GetAccepted() bool {
	if m != nil {
		return m.Accepted
	}
	return false
}

func (m *QueueTask_Acknowledgement) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *QueueTask_Acknowledgement) GetTimeout() bool {
	if m != nil {
		return m.Timeout
	}
	return false
}

func (m *QueueTask_Acknowledgement) GetAborted() bool {
	if m != nil {
		return m.Aborted
	}
	return false
}

func (m *QueueTask_Acknowledgement) GetDismissed() bool {
	if m != nil {
		return m.Dismissed
	}
	return false
}

type Queued struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Queued) Reset()                    { *m = Queued{} }
func (m *Queued) String() string            { return proto.CompactTextString(m) }
func (*Queued) ProtoMessage()               {}
func (*Queued) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Queued) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Rejected struct {
	Id     string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Reason string `protobuf:"bytes,10,opt,name=reason" json:"reason,omitempty"`
}

func (m *Rejected) Reset()                    { *m = Rejected{} }
func (m *Rejected) String() string            { return proto.CompactTextString(m) }
func (*Rejected) ProtoMessage()               {}
func (*Rejected) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Rejected) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Rejected) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type Attached struct {
	Originator string `protobuf:"bytes,4,opt,name=originator" json:"originator,omitempty"`
}

func (m *Attached) Reset()                    { *m = Attached{} }
func (m *Attached) String() string            { return proto.CompactTextString(m) }
func (*Attached) ProtoMessage()               {}
func (*Attached) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Attached) GetOriginator() string {
	if m != nil {
		return m.Originator
	}
	return ""
}

type Subscribed struct {
	Originator string `protobuf:"bytes,4,opt,name=originator" json:"originator,omitempty"`
}

func (m *Subscribed) Reset()                    { *m = Subscribed{} }
func (m *Subscribed) String() string            { return proto.CompactTextString(m) }
func (*Subscribed) ProtoMessage()               {}
func (*Subscribed) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Subscribed) GetOriginator() string {
	if m != nil {
		return m.Originator
	}
	return ""
}

type Accept struct {
	Queue   string `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	Id      string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Subject string `protobuf:"bytes,3,opt,name=subject" json:"subject,omitempty"`
	Payload []byte `protobuf:"bytes,9,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Accept) Reset()                    { *m = Accept{} }
func (m *Accept) String() string            { return proto.CompactTextString(m) }
func (*Accept) ProtoMessage()               {}
func (*Accept) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Accept) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *Accept) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Accept) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Accept) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Attach struct {
	Originator string `protobuf:"bytes,4,opt,name=originator" json:"originator,omitempty"`
}

func (m *Attach) Reset()                    { *m = Attach{} }
func (m *Attach) String() string            { return proto.CompactTextString(m) }
func (*Attach) ProtoMessage()               {}
func (*Attach) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Attach) GetOriginator() string {
	if m != nil {
		return m.Originator
	}
	return ""
}

type Subscribe struct {
	Queue    []string `protobuf:"bytes,1,rep,name=queue" json:"queue,omitempty"`
	Subject  []string `protobuf:"bytes,3,rep,name=subject" json:"subject,omitempty"`
	Sequence int64    `protobuf:"varint,8,opt,name=sequence" json:"sequence,omitempty"`
}

func (m *Subscribe) Reset()                    { *m = Subscribe{} }
func (m *Subscribe) String() string            { return proto.CompactTextString(m) }
func (*Subscribe) ProtoMessage()               {}
func (*Subscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Subscribe) GetQueue() []string {
	if m != nil {
		return m.Queue
	}
	return nil
}

func (m *Subscribe) GetSubject() []string {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *Subscribe) GetSequence() int64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type Ping struct {
	Alive bool `protobuf:"varint,1,opt,name=alive" json:"alive,omitempty"`
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Ping) GetAlive() bool {
	if m != nil {
		return m.Alive
	}
	return false
}

type Pong struct {
	Alive bool `protobuf:"varint,1,opt,name=alive" json:"alive,omitempty"`
}

func (m *Pong) Reset()                    { *m = Pong{} }
func (m *Pong) String() string            { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()               {}
func (*Pong) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Pong) GetAlive() bool {
	if m != nil {
		return m.Alive
	}
	return false
}

type Accepted struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Accepted) Reset()                    { *m = Accepted{} }
func (m *Accepted) String() string            { return proto.CompactTextString(m) }
func (*Accepted) ProtoMessage()               {}
func (*Accepted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Accepted) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Done struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Done) Reset()                    { *m = Done{} }
func (m *Done) String() string            { return proto.CompactTextString(m) }
func (*Done) ProtoMessage()               {}
func (*Done) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Done) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Timeouted struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Timeouted) Reset()                    { *m = Timeouted{} }
func (m *Timeouted) String() string            { return proto.CompactTextString(m) }
func (*Timeouted) ProtoMessage()               {}
func (*Timeouted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Timeouted) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Aborted struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Aborted) Reset()                    { *m = Aborted{} }
func (m *Aborted) String() string            { return proto.CompactTextString(m) }
func (*Aborted) ProtoMessage()               {}
func (*Aborted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Aborted) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Dismissed struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Dismissed) Reset()                    { *m = Dismissed{} }
func (m *Dismissed) String() string            { return proto.CompactTextString(m) }
func (*Dismissed) ProtoMessage()               {}
func (*Dismissed) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Dismissed) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type InProgress struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *InProgress) Reset()                    { *m = InProgress{} }
func (m *InProgress) String() string            { return proto.CompactTextString(m) }
func (*InProgress) ProtoMessage()               {}
func (*InProgress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *InProgress) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterType((*AckToHub)(nil), "AckToHub")
	proto.RegisterType((*AckFromHub)(nil), "AckFromHub")
	proto.RegisterType((*QueueTask)(nil), "QueueTask")
	proto.RegisterType((*QueueTask_Acknowledgement)(nil), "QueueTask.Acknowledgement")
	proto.RegisterType((*Queued)(nil), "Queued")
	proto.RegisterType((*Rejected)(nil), "Rejected")
	proto.RegisterType((*Attached)(nil), "Attached")
	proto.RegisterType((*Subscribed)(nil), "Subscribed")
	proto.RegisterType((*Accept)(nil), "Accept")
	proto.RegisterType((*Attach)(nil), "Attach")
	proto.RegisterType((*Subscribe)(nil), "Subscribe")
	proto.RegisterType((*Ping)(nil), "Ping")
	proto.RegisterType((*Pong)(nil), "Pong")
	proto.RegisterType((*Accepted)(nil), "Accepted")
	proto.RegisterType((*Done)(nil), "Done")
	proto.RegisterType((*Timeouted)(nil), "Timeouted")
	proto.RegisterType((*Aborted)(nil), "Aborted")
	proto.RegisterType((*Dismissed)(nil), "Dismissed")
	proto.RegisterType((*InProgress)(nil), "InProgress")
	proto.RegisterEnum("QueueTask_Persistence", QueueTask_Persistence_name, QueueTask_Persistence_value)
	proto.RegisterEnum("QueueTask_Delivery", QueueTask_Delivery_name, QueueTask_Delivery_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Queue service

type QueueClient interface {
	Ack(ctx context.Context, opts ...grpc.CallOption) (Queue_AckClient, error)
}

type queueClient struct {
	cc *grpc.ClientConn
}

func NewQueueClient(cc *grpc.ClientConn) QueueClient {
	return &queueClient{cc}
}

func (c *queueClient) Ack(ctx context.Context, opts ...grpc.CallOption) (Queue_AckClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Queue_serviceDesc.Streams[0], c.cc, "/Queue/Ack", opts...)
	if err != nil {
		return nil, err
	}
	x := &queueAckClient{stream}
	return x, nil
}

type Queue_AckClient interface {
	Send(*AckToHub) error
	Recv() (*AckFromHub, error)
	grpc.ClientStream
}

type queueAckClient struct {
	grpc.ClientStream
}

func (x *queueAckClient) Send(m *AckToHub) error {
	return x.ClientStream.SendMsg(m)
}

func (x *queueAckClient) Recv() (*AckFromHub, error) {
	m := new(AckFromHub)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Queue service

type QueueServer interface {
	Ack(Queue_AckServer) error
}

func RegisterQueueServer(s *grpc.Server, srv QueueServer) {
	s.RegisterService(&_Queue_serviceDesc, srv)
}

func _Queue_Ack_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueueServer).Ack(&queueAckServer{stream})
}

type Queue_AckServer interface {
	Send(*AckFromHub) error
	Recv() (*AckToHub, error)
	grpc.ServerStream
}

type queueAckServer struct {
	grpc.ServerStream
}

func (x *queueAckServer) Send(m *AckFromHub) error {
	return x.ServerStream.SendMsg(m)
}

func (x *queueAckServer) Recv() (*AckToHub, error) {
	m := new(AckToHub)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Queue_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Queue",
	HandlerType: (*QueueServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Ack",
			Handler:       _Queue_Ack_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "queueproto.proto",
}

func init() { proto.RegisterFile("queueproto.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 862 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x10, 0xa5, 0x44, 0x89, 0x22, 0x47, 0x8e, 0x6d, 0x6c, 0x03, 0x83, 0x55, 0x8c, 0x22, 0x21, 0x0a,
	0xd4, 0x70, 0x13, 0xb6, 0x70, 0x0f, 0xed, 0xa9, 0x00, 0x03, 0x37, 0x50, 0x2f, 0x81, 0xbb, 0x31,
	0x90, 0x33, 0x3f, 0x16, 0xf4, 0x56, 0xd2, 0xae, 0xb2, 0x24, 0x13, 0xf8, 0x77, 0xf4, 0x1f, 0xf5,
	0xd2, 0xff, 0xd2, 0x5f, 0x51, 0xcc, 0x70, 0xf9, 0x51, 0xbb, 0x86, 0x0f, 0xbd, 0xe4, 0x62, 0x68,
	0xde, 0x7b, 0x4b, 0x0e, 0xdf, 0xbc, 0xdd, 0x35, 0x1c, 0x7f, 0x68, 0x44, 0x23, 0xf6, 0x46, 0xd7,
	0x3a, 0xa6, 0xbf, 0xd1, 0x9f, 0x53, 0xf0, 0x93, 0x7c, 0x73, 0xad, 0xd7, 0x4d, 0xc6, 0x5e, 0x80,
	0x97, 0xd6, 0x75, 0x9a, 0xdf, 0x84, 0x93, 0xe7, 0x93, 0xb3, 0xe5, 0xc5, 0x22, 0x4e, 0xa8, 0x5c,
	0x3b, 0xdc, 0x12, 0xec, 0x1c, 0x82, 0xaa, 0xc9, 0xaa, 0xdc, 0xc8, 0x4c, 0x84, 0x53, 0x52, 0x41,
	0xfc, 0xae, 0x43, 0xd6, 0x0e, 0x1f, 0x68, 0x16, 0xc1, 0x9c, 0xde, 0x17, 0xba, 0x56, 0xf7, 0x1b,
	0x56, 0xd7, 0x69, 0xb5, 0x59, 0x3b, 0xbc, 0xa5, 0xd8, 0x33, 0x98, 0xed, 0xa5, 0x2a, 0xc3, 0x39,
	0x49, 0xe6, 0xf1, 0x95, 0x54, 0xe5, 0xda, 0xe1, 0x04, 0xb2, 0x6f, 0xc0, 0x4f, 0xf3, 0x5c, 0xec,
	0x6b, 0x51, 0x84, 0x40, 0x82, 0x20, 0x4e, 0x2c, 0xb0, 0x76, 0x78, 0x4f, 0xe2, 0x53, 0x0a, 0xad,
	0x44, 0xb8, 0xb4, 0x4f, 0xb9, 0xd4, 0x0a, 0x7b, 0x21, 0x90, 0xbd, 0x02, 0x90, 0xea, 0xca, 0xe8,
	0xd2, 0x88, 0xaa, 0x0a, 0x0f, 0x48, 0xb2, 0x8c, 0x7f, 0xed, 0xa1, 0xb5, 0xc3, 0x47, 0x02, 0xfc,
	0xc2, 0x42, 0x56, 0x3b, 0x59, 0x55, 0xa2, 0x08, 0x9f, 0xd8, 0xce, 0x2f, 0x3b, 0x04, 0xbf, 0xb0,
	0xa7, 0x5f, 0xcf, 0xc1, 0xdd, 0x55, 0x65, 0xf4, 0xb7, 0x0b, 0x90, 0xe4, 0x9b, 0x37, 0x46, 0xef,
	0xd0, 0x46, 0x6c, 0x9b, 0xdc, 0x12, 0x85, 0x35, 0x32, 0xb0, 0x46, 0xda, 0xb6, 0xed, 0x6f, 0xec,
	0xac, 0x77, 0xab, 0xb0, 0x6e, 0x2e, 0x07, 0x37, 0x51, 0x3c, 0x12, 0xe0, 0x78, 0xc8, 0xb4, 0xc2,
	0x1a, 0xba, 0x68, 0x0d, 0x45, 0x99, 0x25, 0xf0, 0xd5, 0x46, 0xfc, 0x2e, 0x72, 0x74, 0x6c, 0x66,
	0x5f, 0xcd, 0x2d, 0x80, 0xaf, 0xee, 0x48, 0xf2, 0x5d, 0x8f, 0x7d, 0xd7, 0xd6, 0x77, 0xad, 0x4a,
	0xca, 0x01, 0x59, 0x1b, 0x06, 0x5d, 0x0e, 0xa8, 0xa4, 0x1c, 0xd0, 0xaf, 0xcf, 0x7e, 0x34, 0xa8,
	0xad, 0xe5, 0x4e, 0xe8, 0x06, 0x3b, 0x3c, 0xb4, 0xda, 0xeb, 0x0e, 0x41, 0x6d, 0x4f, 0xb3, 0xaf,
	0x61, 0x91, 0x66, 0xda, 0xa0, 0xf2, 0x88, 0x94, 0x7e, 0x9c, 0xb4, 0xf5, 0xda, 0xe1, 0x1d, 0xd5,
	0x0d, 0xfb, 0xaf, 0x19, 0x04, 0x7d, 0x90, 0xd9, 0xd3, 0x2e, 0xe3, 0x38, 0xe8, 0xa0, 0x4b, 0xf5,
	0x21, 0x4c, 0x65, 0x3b, 0xd0, 0x80, 0x4f, 0x65, 0xc1, 0x42, 0x58, 0x54, 0x4d, 0x86, 0xd6, 0xd3,
	0xe8, 0x02, 0xde, 0x95, 0xec, 0x2b, 0x00, 0x6d, 0x64, 0x29, 0x55, 0x5a, 0x6b, 0x43, 0x23, 0x0b,
	0xf8, 0x08, 0xc1, 0x95, 0xb6, 0x4f, 0x1a, 0xd5, 0x8c, 0x77, 0x25, 0xfb, 0x09, 0x96, 0x7b, 0x61,
	0x2a, 0x59, 0xd5, 0x42, 0xe5, 0x22, 0xf4, 0x9e, 0x4f, 0xce, 0x0e, 0x2f, 0x4e, 0x86, 0x3d, 0x16,
	0x5f, 0x0d, 0x2c, 0x1f, 0x4b, 0xd9, 0x77, 0xe0, 0x17, 0x62, 0x2b, 0x3f, 0x0a, 0x73, 0x1b, 0x2e,
	0x68, 0xd9, 0x17, 0xa3, 0x65, 0x97, 0x96, 0xe2, 0xbd, 0x88, 0xbd, 0x04, 0x37, 0xcd, 0x37, 0xa1,
	0x4f, 0xde, 0xac, 0x46, 0xda, 0x24, 0xdf, 0x28, 0xfd, 0x69, 0x2b, 0x8a, 0x52, 0xec, 0x84, 0xaa,
	0x39, 0xca, 0xb0, 0xe5, 0x7d, 0x7a, 0xbb, 0xd5, 0x69, 0x41, 0xf1, 0x39, 0xe0, 0x5d, 0xb9, 0xfa,
	0x63, 0x02, 0x47, 0x77, 0x96, 0xb0, 0xd5, 0x28, 0x48, 0x68, 0x98, 0x3f, 0xca, 0x0e, 0xb3, 0xd9,
	0x71, 0x09, 0x6f, 0x23, 0x33, 0x32, 0x64, 0x46, 0x70, 0x6f, 0x48, 0x38, 0x4c, 0x71, 0xde, 0x32,
	0xb6, 0x64, 0xa7, 0xe3, 0xdc, 0x78, 0xc4, 0x0d, 0x40, 0xf4, 0x23, 0x2c, 0x47, 0x56, 0xb1, 0x23,
	0x58, 0xbe, 0x37, 0xb2, 0x16, 0xb5, 0xd1, 0x4d, 0x79, 0x73, 0xec, 0xb0, 0x27, 0x10, 0x10, 0x90,
	0xa5, 0xf9, 0xe6, 0x78, 0xc2, 0x7c, 0x98, 0xbd, 0xd5, 0x4a, 0x1c, 0x4f, 0xa3, 0x9f, 0xc1, 0xef,
	0xcc, 0x62, 0x00, 0x5e, 0xa2, 0x6e, 0x11, 0x77, 0xd8, 0x01, 0xf8, 0xbf, 0x20, 0x88, 0xd5, 0x84,
	0x85, 0xf0, 0xb4, 0xab, 0xde, 0xea, 0x4f, 0x89, 0x2a, 0xde, 0x34, 0x75, 0x63, 0x70, 0x7d, 0x08,
	0x5e, 0xbb, 0x81, 0xef, 0xe6, 0x25, 0xba, 0x00, 0xbf, 0xdb, 0xb5, 0xf7, 0xb2, 0x74, 0x02, 0x9e,
	0x11, 0x69, 0xa5, 0x15, 0xed, 0xbb, 0x80, 0xdb, 0x2a, 0x3a, 0x07, 0xbf, 0x3b, 0x64, 0x1e, 0x4b,
	0x55, 0xf4, 0x12, 0x60, 0x38, 0x65, 0x1e, 0x55, 0x67, 0xe0, 0xb5, 0x5b, 0xfb, 0x7f, 0xa7, 0xfd,
	0xc1, 0x68, 0x44, 0x67, 0xe0, 0xb5, 0xdd, 0x3f, 0xda, 0xcd, 0x7b, 0x08, 0xfa, 0xde, 0xc7, 0x0d,
	0xb9, 0x43, 0x43, 0xff, 0x6a, 0xc0, 0x1d, 0x37, 0xb0, 0x02, 0xbf, 0x12, 0x1f, 0x1a, 0xda, 0x31,
	0x18, 0x67, 0x97, 0xf7, 0x75, 0x74, 0x0a, 0x33, 0xbc, 0x7d, 0xf0, 0x99, 0x29, 0x4e, 0x95, 0x3e,
	0xd2, 0xe7, 0x6d, 0x41, 0xac, 0x7e, 0x90, 0x5d, 0xe1, 0x2d, 0x6a, 0x53, 0x7b, 0x77, 0x98, 0x27,
	0x30, 0xc3, 0x43, 0xef, 0x1e, 0xfe, 0x0c, 0x82, 0xfe, 0x3c, 0xba, 0x47, 0x7e, 0x09, 0x0b, 0x7b,
	0x04, 0xfd, 0xd7, 0xba, 0xfe, 0xcc, 0xbb, 0x47, 0x9e, 0x02, 0x0c, 0xc7, 0xe7, 0x5d, 0xf6, 0xe2,
	0x1c, 0xe6, 0x94, 0x38, 0xf6, 0x02, 0xdc, 0x24, 0xdf, 0x30, 0x3c, 0xb3, 0xdb, 0xbb, 0x7f, 0xb5,
	0x8c, 0x87, 0x1b, 0xec, 0x6c, 0xf2, 0xfd, 0xe4, 0xf5, 0x2b, 0xf8, 0x36, 0xd7, 0xbb, 0xb8, 0x94,
	0xf5, 0x4d, 0x93, 0xc5, 0x5a, 0xe9, 0x8d, 0x56, 0x62, 0x17, 0x57, 0x72, 0xbb, 0xbd, 0xa5, 0x87,
	0xbc, 0x13, 0xe6, 0xa3, 0x30, 0x71, 0xbe, 0x95, 0x42, 0xd5, 0x99, 0x47, 0xff, 0x4f, 0xfc, 0xf0,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7e, 0xd2, 0xd9, 0x67, 0x63, 0x08, 0x00, 0x00,
}
